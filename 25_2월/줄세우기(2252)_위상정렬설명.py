"""
ë¦¬ìŠ¤íŠ¸ ì•ˆì— 
bê°€ ìˆì„ ë•Œ 
ì—†ì„ë•Œ

aê°€ ìˆì„ ë•Œ bê°€ ìˆìœ¼ë©´ bì•ì— ë°°ì¹˜ bê°€ ì—†ìœ¼ë©´ ans.append(a) í•˜ê³  ans.append(b)í•˜ê¸°
ì—†ì„ ë•Œ bê°€ ìˆìœ¼ë©´ b ì•ì— ë°°ì¹˜ bê°€ ì—†ìœ¼ë©´ ans.append(a) í•˜ê³  ans.append(b) í•˜ê¸°
"""
"""ì²«ë²ˆì§¸ í’€ì´
N, M = map(int, input().split())

man = [range(1, N+1)]
ans = []

for _ in range(M):
    a, b= map(int, input().split()) # Aê°€ Bì•ì— ì„œì•¼ëœë‹¤.
    
    # if b in ans:
    #     i = ans.index(b)
    #     ans.insert(i, a)
    #     continue
    
    if a in ans:
        i = ans.index(a)
        a = ans.pop(i)
        if b in ans:
            j = ans.index(b)
            ans.insert(j, a)
        else:
            ans.append(a)
            ans.append(b)
    else:
        if b in ans:
            j = ans.index(b)
            ans.insert(j, a)
        else:
            ans.append(a)
            ans.append(b)


print(" ".join(map(str, ans)))"""
import sys
sys.setrecursionlimit(100000)

N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
visited = [False] * (N+1)
stack = []

# ê°„ì„  ì •ë³´ ì…ë ¥ë°›ê¸°
for _ in range(M):
    A, B = map(int, input().split())
    graph[A].append(B)

# DFS í•¨ìˆ˜
def dfs(node):
    visited[node] = True
    for next_node in graph[node]:
        if not visited[next_node]:
            dfs(next_node)
    stack.append(node)  # ëª¨ë“  ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ í›„ ìŠ¤íƒì— ì¶”ê°€

# ìœ„ìƒ ì •ë ¬ ì‹¤í–‰
def topological_sort():
    for i in range(1, N+1):
        if not visited[i]:
            dfs(i)
    
    stack.reverse()  # ìŠ¤íƒì„ ë’¤ì§‘ì–´ì„œ ì¶œë ¥
    print(" ".join(map(str, stack)))

topological_sort()



"""
ìœ„ìƒ ì •ë ¬ì„ ì´í•´í•˜ë ¤ë©´ ê·¸ë˜í”„ ì´ë¡ ì˜ ê¸°ë³¸ ê°œë…ì„ ì•Œê³  ìˆì–´ì•¼ í•´!
ì•„ë˜ ê°œë…ë“¤ì„ ë¨¼ì € ìµíˆë©´ ìœ„ìƒ ì •ë ¬ì„ ë” ì‰½ê²Œ ì´í•´í•  ìˆ˜ ìˆì–´.

1ï¸âƒ£ ê·¸ë˜í”„(Graph)ë€?
	â€¢	ì—¬ëŸ¬ ê°œì˜ ë…¸ë“œ(ì •ì , Vertex) ì™€ ê°„ì„ (Edge) ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ìë£Œêµ¬ì¡°.
	â€¢	ë…¸ë“œ(Node, Vertex): ë°ì´í„°ë¥¼ ë‹´ê³  ìˆëŠ” ì .
	â€¢	ê°„ì„ (Edge): ë…¸ë“œ ê°„ì˜ ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì„ .

ğŸ“Œ ì˜ˆì œ (ë…¸ë“œ 1~5ê°€ ìˆê³ , ê°„ì„ ì´ ì—°ê²°ëœ ê·¸ë˜í”„)

1 â†’ 2 â†’ 5  
â†“    â†“  
3 â†’ 4  

ì´ ê·¸ë˜í”„ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ ê°€ëŠ¥:

graph = {
    1: [2, 3],
    2: [5, 4],
    3: [4],
    4: [],
    5: []
}

2ï¸âƒ£ ë°©í–¥ ê·¸ë˜í”„ vs ë¬´ë°©í–¥ ê·¸ë˜í”„
	â€¢	ë°©í–¥ ê·¸ë˜í”„ (Directed Graph): ê°„ì„ ì— ë°©í–¥ì´ ìˆìŒ. (ì˜ˆ: 1 â†’ 2)
	â€¢	ë¬´ë°©í–¥ ê·¸ë˜í”„ (Undirected Graph): ê°„ì„ ì´ ì–‘ë°©í–¥. (ì˜ˆ: 1 - 2)

ğŸ“Œ ìœ„ìƒ ì •ë ¬ì€ ë°˜ë“œì‹œ ë°©í–¥ ê·¸ë˜í”„ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥!
(ë°©í–¥ì´ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œëŠ” ìˆœì„œë¥¼ ì •í•˜ëŠ” ê°œë…ì´ ì„±ë¦½í•˜ì§€ ì•ŠìŒ.)

3ï¸âƒ£ ì‚¬ì´í´(Cycle) ì—†ëŠ” ê·¸ë˜í”„ (DAG)

ìœ„ìƒ ì •ë ¬ì´ ë™ì‘í•˜ë ¤ë©´ DAG(Directed Acyclic Graph) ì—¬ì•¼ í•´!
	â€¢	DAG: ë°©í–¥ ê·¸ë˜í”„ë©´ì„œ ì‚¬ì´í´ì´ ì—†ëŠ” ê·¸ë˜í”„
	â€¢	ë§Œì•½ ê·¸ë˜í”„ì— ì‚¬ì´í´ì´ ìˆìœ¼ë©´ ìœ„ìƒ ì •ë ¬ ë¶ˆê°€ëŠ¥

ğŸ“Œ ì‚¬ì´í´ ì˜ˆì‹œ (ìœ„ìƒ ì •ë ¬ ë¶ˆê°€ëŠ¥!)

1 â†’ 2 â†’ 3  
â†‘       â†“  
5 â† 4  

	â€¢	1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 1ë¡œ ìˆœí™˜(ì‚¬ì´í´) ì´ ìˆì–´ì„œ ìœ„ìƒ ì •ë ¬ ë¶ˆê°€ëŠ¥!

ğŸ“Œ DAG ì˜ˆì‹œ (ìœ„ìƒ ì •ë ¬ ê°€ëŠ¥!)

1 â†’ 2 â†’ 3  
â†“    â†“  
4    5  

	â€¢	ì‚¬ì´í´ì´ ì—†ì–´ì„œ ìœ„ìƒ ì •ë ¬ ê°€ëŠ¥!

4ï¸âƒ£ ì§„ì… ì°¨ìˆ˜ (Indegree)
	â€¢	ì§„ì… ì°¨ìˆ˜ë€ í•œ ë…¸ë“œë¡œ ë“¤ì–´ì˜¤ëŠ” ê°„ì„ ì˜ ê°œìˆ˜
	â€¢	ìœ„ìƒ ì •ë ¬ì—ì„œëŠ” ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ ë¨¼ì € ì²˜ë¦¬

ğŸ“Œ ì˜ˆì œ:

1 â†’ 2 â†’ 3  
â†“    â†“  
4    5  

ì§„ì… ì°¨ìˆ˜ êµ¬í•˜ê¸°:
	â€¢	1: 0 (ë“¤ì–´ì˜¤ëŠ” ê°„ì„  ì—†ìŒ)
	â€¢	2: 1 (1 â†’ 2)
	â€¢	3: 1 (2 â†’ 3)
	â€¢	4: 1 (1 â†’ 4)
	â€¢	5: 1 (2 â†’ 5)

ìœ„ìƒ ì •ë ¬ì€ í•­ìƒ ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¶€í„° ì²˜ë¦¬!

ğŸ“Œ ì •ë¦¬: ìœ„ìƒ ì •ë ¬ì„ ì´í•´í•˜ë ¤ë©´?

âœ… ê·¸ë˜í”„ ê°œë… (ë…¸ë“œ, ê°„ì„ )
âœ… ë°©í–¥ ê·¸ë˜í”„ vs ë¬´ë°©í–¥ ê·¸ë˜í”„ ì°¨ì´
âœ… ì‚¬ì´í´ì´ ì—†ëŠ” ê·¸ë˜í”„ (DAG)
âœ… ì§„ì… ì°¨ìˆ˜ (Indegree) ê°œë…

ì´ê±¸ ì´í•´í•˜ë©´ ìœ„ìƒ ì •ë ¬ì´ í›¨ì”¬ ì‰½ê²Œ ë‹¤ê°€ì˜¬ ê±°ì•¼!
ê·¸ë˜ë„ í—·ê°ˆë¦¬ë©´ ì§ˆë¬¸í•´ì¤˜ ğŸ˜Š

ìœ„ìƒ ì •ë ¬ì„ ê°„ë‹¨í•œ ì½”ë“œë¡œ ì„¤ëª…í•´ë³¼ê²Œ!
ìœ„ìƒ ì •ë ¬ì„ êµ¬í˜„í•˜ëŠ” ëŒ€í‘œì ì¸ ë°©ë²• ë‘ ê°€ì§€ë¥¼ ì½”ë“œë¡œ ë³´ì—¬ì¤„ê²Œ.

1ï¸âƒ£ ì§„ì… ì°¨ìˆ˜ë¥¼ ì´ìš©í•œ ìœ„ìƒ ì •ë ¬ (Kahnâ€™s Algorithm)

ì•„ì´ë””ì–´:
	â€¢	ì§„ì… ì°¨ìˆ˜(indegree, ë“¤ì–´ì˜¤ëŠ” ê°„ì„ ì˜ ê°œìˆ˜)ê°€ 0ì¸ ë…¸ë“œë¥¼ ë¨¼ì € ì²˜ë¦¬í•œë‹¤.
	â€¢	ê·¸ ë…¸ë“œì™€ ì—°ê²°ëœ ê°„ì„ ì„ ì œê±°í•˜ê³ , ìƒˆë¡­ê²Œ ì§„ì… ì°¨ìˆ˜ê°€ 0ì´ ëœ ë…¸ë“œë¥¼ íì— ë„£ëŠ”ë‹¤.
	â€¢	ì´ë¥¼ ë°˜ë³µí•˜ë©´ ì •ë ¬ëœ ìˆœì„œê°€ ë‚˜ì˜¨ë‹¤.

from collections import deque

# ê·¸ë˜í”„ ì…ë ¥ ë°›ê¸°
N, M = map(int, input().split())  # ë…¸ë“œ ê°œìˆ˜ N, ê°„ì„  ê°œìˆ˜ M
graph = [[] for _ in range(N+1)]
indegree = [0] * (N+1)

# ê°„ì„  ì •ë³´ ì…ë ¥ë°›ê¸°
for _ in range(M):
    A, B = map(int, input().split())  # Aê°€ Bë³´ë‹¤ ë¨¼ì € ì™€ì•¼ í•¨
    graph[A].append(B)
    indegree[B] += 1  # Bì˜ ì§„ì… ì°¨ìˆ˜ ì¦ê°€

# ìœ„ìƒ ì •ë ¬ ì‹¤í–‰
def topological_sort():
    result = []  # ì •ë ¬ëœ ê²°ê³¼ ì €ì¥
    q = deque()

    # ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ íì— ì‚½ì…
    for i in range(1, N+1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        now = q.popleft()
        result.append(now)

        # í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œë“¤ì˜ ì§„ì… ì°¨ìˆ˜ ê°ì†Œ
        for next_node in graph[now]:
            indegree[next_node] -= 1
            if indegree[next_node] == 0:
                q.append(next_node)

    print(" ".join(map(str, result)))

topological_sort()

ğŸ“Œ ì‹œê°„ë³µì¡ë„:
	â€¢	ëª¨ë“  ê°„ì„ ì„ í•œ ë²ˆì”© íƒìƒ‰ â†’ O(N + M)
	â€¢	íë¥¼ ì‚¬ìš©í•´ì„œ ë¹ ë¥´ê²Œ ì •ë ¬ ê°€ëŠ¥

2ï¸âƒ£ DFSë¥¼ ì´ìš©í•œ ìœ„ìƒ ì •ë ¬

ì•„ì´ë””ì–´:
	â€¢	ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œì—ì„œ DFSë¥¼ ìˆ˜í–‰
	â€¢	ì¬ê·€ í˜¸ì¶œì´ ëë‚˜ë©´ ìŠ¤íƒì— ë…¸ë“œë¥¼ ì¶”ê°€
	â€¢	ìŠ¤íƒì„ ë’¤ì§‘ì–´ì„œ ìœ„ìƒ ì •ë ¬ ê²°ê³¼ë¥¼ ì–»ìŒ

import sys
sys.setrecursionlimit(100000)

N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
visited = [False] * (N+1)
stack = []

# ê°„ì„  ì •ë³´ ì…ë ¥ë°›ê¸°
for _ in range(M):
    A, B = map(int, input().split())
    graph[A].append(B)

# DFS í•¨ìˆ˜
def dfs(node):
    visited[node] = True
    for next_node in graph[node]:
        if not visited[next_node]:
            dfs(next_node)
    stack.append(node)  # ëª¨ë“  ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸ í›„ ìŠ¤íƒì— ì¶”ê°€

# ìœ„ìƒ ì •ë ¬ ì‹¤í–‰
def topological_sort():
    for i in range(1, N+1):
        if not visited[i]:
            dfs(i)
    
    stack.reverse()  # ìŠ¤íƒì„ ë’¤ì§‘ì–´ì„œ ì¶œë ¥
    print(" ".join(map(str, stack)))

topological_sort()

ğŸ“Œ ì‹œê°„ë³µì¡ë„:
	â€¢	ëª¨ë“  ë…¸ë“œë¥¼ í•œ ë²ˆ ë°©ë¬¸í•˜ë©´ì„œ íƒìƒ‰ â†’ O(N + M)

âœ… ì–´ë–¤ ë°©ë²•ì„ ì„ íƒí•´ì•¼ í• ê¹Œ?
	â€¢	í(BFS ë°©ì‹, Kahnâ€™s Algorithm) â†’ ë” ì§ê´€ì ì´ê³ , ì½”ë“œê°€ ê°„ê²°í•´ì„œ ì‹¤ì „ì—ì„œ ë” ìì£¼ ì‚¬ìš©ë¨
	â€¢	DFS ë°©ì‹ â†’ ì¬ê·€ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì„ ë•Œ ìœ ìš©í•˜ë©°, ìŠ¤íƒì„ í™œìš©í•œ ì ‘ê·¼ì´ í•„ìš”í•  ë•Œ ì‚¬ìš©ë¨

ìœ„ìƒ ì •ë ¬ ì´í•´ëì–´? ë” ê¶ê¸ˆí•œ ê±° ìˆìœ¼ë©´ ì§ˆë¬¸í•´ì¤˜! ğŸ˜Š
"""